---
title: Iniciando com React Hooks - useEffect
resume: Existem situa√ß√µes em que nossa aplica√ß√£o precisa executar trechos de
  c√≥digos com base em mudan√ßas de estado , esses acontecimentos s√£o  conhecido
  como efeitos colaterais e podem ser controladas utilizando o hook useEffect.
date: 2021-04-06 10:28:46
image: assets/img/react.png
category: React
tagColor: "#3498db"
---
Hey, esse artigo faz parte de uma s√©rie sobre react hooks. Se voc√™ ainda n√£o leu os artigos passados, da uma conferida nos links abaixo:

* [Iniciando com React Hooks - useState](https://www.crisgon.dev/iniciando-com-react-hooks-usestate/)

![React JS](assets/img/hooks-wallpaper.png)

A primeira coisa que precisa ficar clara √© que o hook `useEffect` n√£o √© uma vers√£o dos ciclos de vida`constructor`, `componentDidMount`, `componentDidUpdate`, e `componentWillUnmount`.

Isso mesmo, provavelmente voc√™ entendeu errado... assim como eu. Mas nunca √© tarde para aprender, ent√£o vamos l√°.

### T√°, mas o que √© o useEffect?

`useEffect` √© um hook que tem como principal objetivo sincronizar estados e executar efeitos colaterais. Esse hook √© uma fun√ß√£o que pode receber at√© 2 argumentos, uma fun√ß√£o e um array de depend√™ncias. 

Geralmente o que encontramos por ai √© uma explica√ß√£o que diz o seguinte:

* usar o `useEffect` passando apenas o primeiro `useEffect(function)`

  ‚ùå Quer dizer que esse `useEffect` vai ser executado sempre que nossa aplica√ß√£o atualizar, semelhante ao `componentDidUpdate`

  ‚úÖ O correto √© dizer que esse `useEffect` vai estar em sincronia com todos os estados do componente.
* usar o `useEffect` passando o segundo argumento como um array vazio `useEffect(function, [])`

  ‚ùå Quer dizer que esse `useEffect` vai ser executado quando o componente montar, semelhante ao `componentDidMount`

  ‚úÖ O correto √© dizer que esse `useEffect` n√£o vai estar em sincronia com nenhum estado do componente, por isso ele vai ser executado apenas uma vez.
* usar o `useEffect` passando uma lista de estados no segundo argumento

  ‚ùå Quer dizer que esse `useEffect` vai ser executado sempre que os estados  atualizarem, semelhante ao `componentDidUpdate.`Tamb√©m existem algumas explica√ß√µes que tratam essa forma como uma alternativa ao antigo `componentWillReceiveProps`

  ‚úÖ O correto √© dizer que esse `useEffect` vai estar em sincronia com todos os estados que forem passados no segundo argumento.

Pode parecer besteira, mas √© importante entender essas  pequenas diferen√ßas. 

### Ainda n√£o ficou claro? Vamos ao exemplo!

Vamos utilizar um exemplo bem simples utilizando Classes e logo em seguida o mesmo componente utilizando hooks.

```javascript
export class SimpleComponent extends Component {
  componentDidMount() {
    alert('Component montou!')
  }

  componentWillUnmount() {
    alert('Component desmontou');
  }

  render() {
    return (
      <h1>Component Simples</h1>
    );
  }
}
```

```javascript
export function SimpleComponent() {
  useEffect(() => {
    alert('Component montou!');
    
    return alert('Component desmontou');
  }, []);
  
  return <h1>Component Simples</h1>;
}
```

Dois pontos s√£o bem importantes no c√≥digo acima: 

1. O c√≥digo que vai ser executado quando o componente for desmontar √© passado no retorno da fun√ß√£o do `useEffect`. 
2. O segundo argumento passado para o `useEffect` √© um array vazio, pois n√£o queremos que ele sincronize com nenhum estado.

##### Vamos para mais um exemplo!

```javascript
export class PokemonInfo extends Component {
  state = { pokemon: null };
  
   getPokemon() {
    api.getPokemonInfo(this.props.pokemonNumber)
    .then((pokemon) => {
      this.setState({pokemon})
    });
  }
  
  componentDidUpdate(prevProps){
     if (prevProps.pokemonNumber !== this.props.pokemonNumber) {
      this.getPokemon();
    }
  }

  render() {
    return (
      <>
      <input type="number" value={this.props.pokemonNumber} onChange={this.props.changePokemonNumber} />
      <h1>{this.state.pokemon.name}</h1>
      </>
    );
  }
}
```

```javascript
export function PokemonInfo(props){

  const [pokemon, setPokemon] = useState(null);

  state = { pokemon: null };
  
   function getPokemon() {
    api.getPokemonInfo(pokemonNumber)
    .then((poke) => {
      setPokemon(poke)
    });
  }

  useEffect(() => {
    getPokemon()
  }, [props.pokemonNumber])
  
  componentDidUpdate(prevProps){
     if (prevProps.pokemonNumber !== this.props.pokemonNumber) {
      this.getPokemon();
    }
  }

    return (
      <>
      <input type="number" value={props.pokemonNumber} onChange={props.changePokemonNumber} />
      <h1>{pokemon.name}</h1>
      </>
    );
}
```

No exemplo acima √© importante notar que nosso hook se `useEffect` recebeu uma prop  no array do seu segundo argumento. Isso quer dizer que queremos manter esse `useEffect` em sincronia com a prop chamada `pokemonNumer`. 

### Evite ter um √∫nico useEffect gigantesco

Isso √© algo bastante comum e acontece porque na maioria das vezes confundimos `useEffect` com ciclos de vida do react. Sempre falamos "vou chamar todas as fun√ß√µes aqui porque quero executar apenas quando meu componente montar", mas `useEffect` √© sobre sincronizar estados e n√£o sobre ciclos de vida. 

Antes dos hooks n√≥s escrev√≠amos algo assim, pois era baseado em ciclos de vida.

```javascript
class ChatFeed extends React.Component {
  componentDidMount() {
    this.subscribeToFeed()
    this.setDocumentTitle()
    this.subscribeToOnlineStatus()
    this.subscribeToGeoLocation()
  }
  componentWillUnmount() {
    this.unsubscribeFromFeed()
    this.restoreDocumentTitle()
    this.unsubscribeFromOnlineStatus()
    this.unsubscribeFromGeoLocation()
  }
  componentDidUpdate(prevProps, prevState) {
    // ... compare props and re-subscribe etc.
  }
  render() {
    return <div>{/* chat app UI */}</div>
  }
}
```

Por falta de entendimento do funcionamento do `useEffect` √© comum imaginar que a melhor abordagem √© escrever  o mesmo c√≥digo em hooks dessa forma:

```javascript
function ChatFeed() {
  React.useEffect(() => {
    subscribeToFeed();
    setDocumentTitle();
    subscribeToOnlineStatus();
    subscribeToGeoLocation();
    
    return () => {
     unsubscribeFromFeed();
     restoreDocumentTitle();
     unsubscribeFromOnlineStatus();
     unsubscribeFromGeoLocation();
    }
  });
  
   return <div>{/* chat app UI */}</div>

}
```

Podemos utilizar um `useEffect` para cada l√≥gica individual!

```javascript
function ChatFeed() {
  React.useEffect(() => {
    subscribeToFeed();
    return () => {
      unsubscribeFromFeed();
    }
  })
  React.useEffect(() => {
    setDocumentTitle();
    return () => {
      restoreDocumentTitle();
    }
  })
  React.useEffect(() => {
    subscribeToOnlineStatus();
    return () => {
      unsubscribeFromOnlineStatus();
    }
  })
  React.useEffect(() => {
    subscribeToGeoLocation();
    return () => {
      unsubscribeFromGeoLocation();
    }
  })
  return <div>{/* chat app UI */}</div>
}
```

Uma solu√ß√£o bastante elegante √© separar tudo em [hooks personalizados](https://pt-br.reactjs.org/docs/hooks-custom.html). N√£o se preocupe, em breve irei abordar esse assunto aqui.

```javascript
function ChatFeed() {
  // Cada hook customizado tem a l√≥gica necess√°ria e poderia retornar valores
  useFeedSubscription();
  useDocumentTitle();
  useOnlineStatus();
  useGeoLocation();
  return <div>{/* chat app UI */}</div>
}
```

### Evite criar fun√ß√µes desnecess√°rias

Nem sempre √© necess√°rio criar uma fun√ß√£o se ela vai ser utilizada a penas no `useEffect`. 

```javascript
import React, {useState, useEffect }  from 'react';

export function PokeInfo(props) {
  const [pokemon, setPokemon] = useState(null);
  
  useEffect(() => {
    getPokemonInfo();
  }, [props.id]);
  
  const getPokemonInfo = useCallback(() => {
    api.getPokemon(props.id).then((poke) => {
      setPokemon(poke);
    }).catch(e => {
      console.error(e.message);
    });
  }, []);


  return <div>{/*Pokemon info*/}<div/>
}
```

Por hora ignore o `useCallback`, em breve teremos um post sobre ele.

```javascript
import React, {useState, useEffect }  from 'react';

export function PokeInfo(props) {
  const [pokemon, setPokemon] = useState(null);
  
  useEffect(() => {
     api.getPokemon(props.id).then((poke) => {
      setPokemon(poke);
    }).catch(e => {
      console.error(e.message);
    });
  }, [props.id]);
  


  return <div>{/*Pokemon info*/}<div/>
}
```

Toda aquela complexidade desnecess√°ria com uma fun√ß√£o que nem estava sendo reaproveitada foi simplificada com o c√≥digo acima. Lembre-se, o primeiro argumento do `useEffect` j√° √© uma fun√ß√£o.

### Isso √© tudo pessoal!

![Isso √© tudo pessoal](https://i.pinimg.com/originals/2a/82/1e/2a821ee45ca3cbc384c0b70f730248ae.gif)

Obrigado por chegar at√© aqui!! Espero que tenha conseguido te ajudar de alguma forma. üòä

Fique atento(a) aqui no blog e no meu [twitter](https://twitter.com/Gonkristiano) que em breve irei postar mais artigos sobre hooks.

### Links importantes

* [Documenta√ß√£o do react](https://pt-br.reactjs.org/docs/getting-started.html)
* [Mitos sobre useEffect](https://epicreact.dev/myths-about-useeffect/)
